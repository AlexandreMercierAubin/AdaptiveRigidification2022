/* mexNeoHookean3D.cpp - computes negative area weighted NeoHookean psi, dpsidF and d2psidF2
 *
 * [ ii, jj, Cvals, dpsidF ] = mexNeoHookean3D( F, V, mu, lambda );
 *
 * Input:
 *  F        9x#E deformation gradient of each element (or a vector of size 9x#E)
 *  V        #E volume of each element
 *  mu       #E Lamé parameter of each element
 *  lambda   #E Lamé parameter of each element
 * 
 * Output:
 *  ii         81x#E by 1 row indices for each C block in a sparse matrix
 *  jj         81x#E by 1 col indices for each C block in a sparse matrix
 *  Cvals      81x#E by 1 energy Hessian wrt F for each eleemnt (scaled by negative volume)
 *  dpsidF     9x#E by 1 energy gradient (scaled by negative volume)
 *
 * To compile type: mex -R2018a mexNeoHookean3D.cpp
 *
 * Notes:
 *
 * Code generated by energy/codeGenNeoHookeanHessian3D.m
 *
 * It is perhaps a tiny bit slower to build the sparse matrix with the 
 * matlab call sparse( ii, jj, Cvals ), rather than creating it here, but 
 * it could also be more useful in the long run to have the non-sparse 
 * version of the Cvals (e.g., a custom non-assembled matrix multiply for
 * the quick solve conjugate gradient).
 *========================================================*/

#include "mex.h"
#include "blas.h"
#include <math.h> 
/* 
 * The gateway function
 */
void mexFunction( int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[] ) {
    // check for proper number of arguments
    if ( nrhs != 4 ) {
        mexErrMsgIdAndTxt("ARP:mexCompute3DSTVKGradHess:nrhs","four inputs required.");
    }
    if ( nlhs != 5 ) {
        mexErrMsgIdAndTxt("ARP:mexCompute3DSTVKGradHess:nlhs","five outputs required.");
    }
    
    // make sure the arguments are dense real double
    if ( !mxIsDouble(prhs[0]) || mxIsComplex(prhs[0]) || mxIsSparse(prhs[0]) ) {
        mexErrMsgIdAndTxt("ARP:mexCompute3DSTVKGradHess:mustBeDenseRealDouble","Parameters must be dense real double.");
    }
    if ( !mxIsDouble(prhs[1]) || mxIsComplex(prhs[1]) || mxIsSparse(prhs[1]) ) {
        mexErrMsgIdAndTxt("ARP:mexCompute3DSTVKGradHess:mustBeDenseRealDouble","Parameters must be dense real double.");
    }
    if ( !mxIsDouble(prhs[2]) || mxIsComplex(prhs[2]) || mxIsSparse(prhs[2]) ) {
        mexErrMsgIdAndTxt("ARP:mexCompute3DSTVKGradHess:mustBeDenseRealDouble","Parameters must be dense real double.");
    }
    if ( !mxIsDouble(prhs[3]) || mxIsComplex(prhs[3]) || mxIsSparse(prhs[3]) ) {
        mexErrMsgIdAndTxt("ARP:mexCompute3DSTVKGradHess:mustBeDenseRealDouble","Parameters must be dense real double.");
    }

    // check sizes    
    size_t Fsize = mxGetNumberOfElements(prhs[0]); // number of rows 
    if ( Fsize % 9 != 0 ) {
        mexErrMsgIdAndTxt("ARP:mexCompute3DSTVKGradHess:FSize","F must be a multiple of 9.");
    }
    size_t m = Fsize / 9;
    if ( mxGetNumberOfElements(prhs[1]) != m || mxGetNumberOfElements(prhs[2]) != m || mxGetNumberOfElements(prhs[3]) != m ) {
        mexErrMsgIdAndTxt("ARP:mexCompute3DSTVKGradHess:RowSize","All inputs must have same number of rows.");
    }
     
    double *FVals = mxGetDoubles(prhs[0]);
    double *VVals = mxGetDoubles(prhs[1]);
    double *muVals = mxGetDoubles(prhs[2]);
    double *lambdaVals = mxGetDoubles(prhs[3]);
    
    // create the output vectors 
    plhs[0] = mxCreateDoubleMatrix( 81*m, 1, mxREAL );
    double *ii = mxGetDoubles(plhs[0]);
    plhs[1] = mxCreateDoubleMatrix( 81*m, 1, mxREAL );
    double *jj = mxGetDoubles(plhs[1]);
    plhs[2] = mxCreateDoubleMatrix( 81*m, 1, mxREAL );
    double *C = mxGetDoubles(plhs[2]);
    plhs[3] = mxCreateDoubleMatrix( 9*m, 1, mxREAL );
    double *dpsidF = mxGetDoubles(plhs[3]);
    plhs[4] = mxCreateDoubleMatrix( m, 1, mxREAL );
    double *psi = mxGetDoubles(plhs[4]);
    
    size_t i = 0;
    size_t j = 0;
    for ( int el = 0; el < m; el++ ) {
        double volume = VVals[el];
        double mu = muVals[el];
        double lambda = lambdaVals[el];
        double F1_1 = FVals[j++];
        double F2_1 = FVals[j++];
        double F3_1 = FVals[j++];
        double F1_2 = FVals[j++];
        double F2_2 = FVals[j++];
        double F3_2 = FVals[j++];
        double F1_3 = FVals[j++];
        double F2_3 = FVals[j++];
        double F3_3 = FVals[j++];
        
        // code gen
        double  t2 = F1_1*F1_1;
        double  t3 = F1_2*F1_2;
        double  t4 = F1_3*F1_3;
        double  t5 = F2_1*F2_1;
        double  t6 = F2_2*F2_2;
        double  t7 = F2_3*F2_3;
        double  t8 = F3_1*F3_1;
        double  t9 = F3_2*F3_2;
        double  t10 = F3_3*F3_3;
        double  t11 = F1_1*F2_2;
        double  t12 = F1_2*F2_1;
        double  t13 = F1_1*F2_3;
        double  t14 = F1_3*F2_1;
        double  t15 = F1_2*F2_3;
        double  t16 = F1_3*F2_2;
        double  t17 = F1_1*F3_2;
        double  t18 = F1_2*F3_1;
        double  t19 = F1_1*F3_3;
        double  t20 = F1_3*F3_1;
        double  t21 = F1_2*F3_3;
        double  t22 = F1_3*F3_2;
        double  t23 = F2_1*F3_2;
        double  t24 = F2_2*F3_1;
        double  t25 = F2_1*F3_3;
        double  t26 = F2_3*F3_1;
        double  t27 = F2_2*F3_3;
        double  t28 = F2_3*F3_2;
        double  t35 = 1.0/lambda;
        double  t29 = F3_3*t11;
        double  t30 = F3_2*t13;
        double  t31 = F3_3*t12;
        double  t32 = F3_1*t15;
        double  t33 = F3_2*t14;
        double  t34 = F3_1*t16;
        double  t36 = -t12;
        double  t37 = -t14;
        double  t38 = -t16;
        double  t39 = -t18;
        double  t40 = -t20;
        double  t41 = -t22;
        double  t42 = -t24;
        double  t43 = -t26;
        double  t44 = -t28;
        double  t57 = mu*t35*(3.0/4.0);
        double  t98 = t2+t3+t4+t5+t6+t7+t8+t9+t10+1.0;
        double  t45 = -t29;
        double  t46 = -t32;
        double  t47 = -t33;
        double  t48 = t11+t36;
        double  t49 = t13+t37;
        double  t50 = t15+t38;
        double  t51 = t17+t39;
        double  t52 = t19+t40;
        double  t53 = t21+t41;
        double  t54 = t23+t42;
        double  t55 = t25+t43;
        double  t56 = t27+t44;
        double  t99 = 1.0/t98;
        double  t58 = lambda*t48*t49;
        double  t59 = lambda*t48*t50;
        double  t60 = lambda*t49*t50;
        double  t61 = lambda*t48*t51;
        double  t62 = lambda*t48*t52;
        double  t63 = lambda*t49*t51;
        double  t64 = lambda*t48*t53;
        double  t65 = lambda*t49*t52;
        double  t66 = lambda*t50*t51;
        double  t67 = lambda*t49*t53;
        double  t68 = lambda*t50*t52;
        double  t69 = lambda*t50*t53;
        double  t70 = lambda*t48*t54;
        double  t71 = lambda*t48*t55;
        double  t72 = lambda*t49*t54;
        double  t73 = lambda*t51*t52;
        double  t74 = lambda*t48*t56;
        double  t75 = lambda*t49*t55;
        double  t76 = lambda*t50*t54;
        double  t77 = lambda*t51*t53;
        double  t78 = lambda*t49*t56;
        double  t79 = lambda*t50*t55;
        double  t80 = lambda*t52*t53;
        double  t81 = lambda*t50*t56;
        double  t82 = lambda*t51*t54;
        double  t83 = lambda*t51*t55;
        double  t84 = lambda*t52*t54;
        double  t85 = lambda*t51*t56;
        double  t86 = lambda*t52*t55;
        double  t87 = lambda*t53*t54;
        double  t88 = lambda*t52*t56;
        double  t89 = lambda*t53*t55;
        double  t90 = lambda*t53*t56;
        double  t91 = lambda*t54*t55;
        double  t92 = lambda*t54*t56;
        double  t93 = lambda*t55*t56;
        double  t100 = t99*t99;
        double  t101 = mu*t99;
        double  t155 = t30+t31+t34+t45+t46+t47+t57+1.0;
        double  t94 = -t64;
        double  t95 = -t71;
        double  t96 = -t78;
        double  t97 = -t85;
        double  t102 = -t101;
        double  t103 = F1_1*F1_2*mu*t100*2.0;
        double  t104 = F1_1*F1_3*mu*t100*2.0;
        double  t105 = F1_2*F1_3*mu*t100*2.0;
        double  t106 = F1_1*F2_1*mu*t100*2.0;
        double  t107 = mu*t11*t100*2.0;
        double  t108 = mu*t12*t100*2.0;
        double  t109 = mu*t13*t100*2.0;
        double  t110 = F1_2*F2_2*mu*t100*2.0;
        double  t111 = mu*t14*t100*2.0;
        double  t112 = mu*t15*t100*2.0;
        double  t113 = mu*t16*t100*2.0;
        double  t114 = F1_3*F2_3*mu*t100*2.0;
        double  t115 = F1_1*F3_1*mu*t100*2.0;
        double  t116 = mu*t17*t100*2.0;
        double  t117 = mu*t18*t100*2.0;
        double  t118 = F2_1*F2_2*mu*t100*2.0;
        double  t119 = mu*t19*t100*2.0;
        double  t120 = F1_2*F3_2*mu*t100*2.0;
        double  t121 = mu*t20*t100*2.0;
        double  t122 = F2_1*F2_3*mu*t100*2.0;
        double  t123 = mu*t21*t100*2.0;
        double  t124 = mu*t22*t100*2.0;
        double  t125 = F2_2*F2_3*mu*t100*2.0;
        double  t126 = F1_3*F3_3*mu*t100*2.0;
        double  t127 = F2_1*F3_1*mu*t100*2.0;
        double  t128 = mu*t23*t100*2.0;
        double  t129 = mu*t24*t100*2.0;
        double  t130 = mu*t25*t100*2.0;
        double  t131 = F2_2*F3_2*mu*t100*2.0;
        double  t132 = mu*t26*t100*2.0;
        double  t133 = mu*t27*t100*2.0;
        double  t134 = mu*t28*t100*2.0;
        double  t135 = F2_3*F3_3*mu*t100*2.0;
        double  t136 = F3_1*F3_2*mu*t100*2.0;
        double  t137 = F3_1*F3_3*mu*t100*2.0;
        double  t138 = F3_2*F3_3*mu*t100*2.0;
        double  t156 = F1_1*lambda*t155;
        double  t157 = F1_2*lambda*t155;
        double  t158 = F1_3*lambda*t155;
        double  t159 = F2_1*lambda*t155;
        double  t160 = F2_2*lambda*t155;
        double  t161 = F2_3*lambda*t155;
        double  t162 = F3_1*lambda*t155;
        double  t163 = F3_2*lambda*t155;
        double  t164 = F3_3*lambda*t155;
        double  t139 = -t103;
        double  t140 = -t105;
        double  t141 = -t106;
        double  t142 = -t110;
        double  t143 = -t111;
        double  t144 = -t114;
        double  t145 = -t117;
        double  t146 = -t118;
        double  t147 = -t124;
        double  t148 = -t125;
        double  t149 = -t127;
        double  t150 = -t131;
        double  t151 = -t132;
        double  t152 = -t135;
        double  t153 = -t136;
        double  t154 = -t138;
        double  t165 = -t156;
        double  t166 = -t158;
        double  t167 = -t160;
        double  t168 = -t162;
        double  t169 = -t164;
        double  t170 = t59+t137;
        double  t171 = t70+t126;
        double  t172 = t75+t120;
        double  t173 = t77+t122;
        double  t174 = t81+t115;
        double  t175 = t92+t104;
        double  t212 = t63+t134+t156;
        double  t213 = t68+t129+t158;
        double  t214 = t76+t121+t160;
        double  t215 = t84+t113+t162;
        double  t216 = t89+t108+t164;
        double  t227 = t94+t130+t157;
        double  t229 = t95+t123+t159;
        double  t231 = t96+t116+t161;
        double  t233 = t97+t109+t163;
        double  t176 = t58+t154;
        double  t177 = t60+t153;
        double  t178 = t61+t152;
        double  t179 = t65+t150;
        double  t180 = t69+t149;
        double  t181 = t73+t148;
        double  t182 = t80+t146;
        double  t183 = t82+t144;
        double  t184 = t86+t142;
        double  t185 = t90+t141;
        double  t186 = t91+t140;
        double  t187 = t93+t139;
        double  t188 = t170*volume;
        double  t189 = t171*volume;
        double  t190 = t172*volume;
        double  t191 = t173*volume;
        double  t192 = t174*volume;
        double  t193 = t175*volume;
        double  t217 = t66+t151+t157;
        double  t218 = t72+t147+t159;
        double  t219 = t79+t145+t161;
        double  t220 = t87+t143+t163;
        double  t221 = t212*volume;
        double  t222 = t213*volume;
        double  t223 = t214*volume;
        double  t224 = t215*volume;
        double  t225 = t216*volume;
        double  t226 = t62+t133+t165;
        double  t228 = t67+t128+t166;
        double  t230 = t74+t119+t167;
        double  t232 = t83+t112+t168;
        double  t234 = t88+t107+t169;
        double  t241 = t227*volume;
        double  t244 = t229*volume;
        double  t247 = t231*volume;
        double  t250 = t233*volume;
        double  t194 = t176*volume;
        double  t195 = t177*volume;
        double  t196 = t178*volume;
        double  t197 = t179*volume;
        double  t198 = t180*volume;
        double  t199 = t181*volume;
        double  t200 = t182*volume;
        double  t201 = t183*volume;
        double  t202 = t184*volume;
        double  t203 = t185*volume;
        double  t204 = t186*volume;
        double  t205 = t187*volume;
        double  t206 = -t188;
        double  t207 = -t189;
        double  t208 = -t190;
        double  t209 = -t191;
        double  t210 = -t192;
        double  t211 = -t193;
        double  t235 = t217*volume;
        double  t236 = t218*volume;
        double  t237 = t219*volume;
        double  t238 = t220*volume;
        double  t239 = t226*volume;
        double  t240 = -t221;
        double  t242 = t228*volume;
        double  t243 = -t222;
        double  t245 = t230*volume;
        double  t246 = -t223;
        double  t248 = t232*volume;
        double  t249 = -t224;
        double  t251 = t234*volume;
        double  t252 = -t225;
        double  t254 = -t241;
        double  t256 = -t244;
        double  t258 = -t247;
        double  t260 = -t250;
        double  t253 = -t239;
        double  t255 = -t242;
        double  t257 = -t245;
        double  t259 = -t248;
        double  t261 = -t251;

        C[i++] = -volume*(mu+t102+lambda*(t56*t56)+mu*t2*t100*2.0);
        C[i++] = t203;
        C[i++] = t210;
        C[i++] = t205;
        C[i++] = t261;
        C[i++] = t258;
        C[i++] = t211;
        C[i++] = t260;
        C[i++] = t257;
        C[i++] = t203;
        C[i++] = -volume*(mu+t102+lambda*(t53*t53)+mu*t5*t100*2.0);
        C[i++] = t198;
        C[i++] = t252;
        C[i++] = t200;
        C[i++] = t255;
        C[i++] = t238;
        C[i++] = t209;
        C[i++] = t254;
        C[i++] = t210;
        C[i++] = t198;
        C[i++] = -volume*(mu+t102+lambda*(t50*t50)+mu*t8*t100*2.0);
        C[i++] = t237;
        C[i++] = t243;
        C[i++] = t195;
        C[i++] = t246;
        C[i++] = t235;
        C[i++] = t206;
        C[i++] = t205;
        C[i++] = t252;
        C[i++] = t237;
        C[i++] = -volume*(mu+t102+lambda*(t55*t55)+mu*t3*t100*2.0);
        C[i++] = t202;
        C[i++] = t208;
        C[i++] = t204;
        C[i++] = t259;
        C[i++] = t256;
        C[i++] = t261;
        C[i++] = t200;
        C[i++] = t243;
        C[i++] = t202;
        C[i++] = -volume*(mu+t102+lambda*(t52*t52)+mu*t6*t100*2.0);
        C[i++] = t197;
        C[i++] = t249;
        C[i++] = t199;
        C[i++] = t253;
        C[i++] = t258;
        C[i++] = t255;
        C[i++] = t195;
        C[i++] = t208;
        C[i++] = t197;
        C[i++] = -volume*(mu+t102+lambda*(t49*t49)+mu*t9*t100*2.0);
        C[i++] = t236;
        C[i++] = t240;
        C[i++] = t194;
        C[i++] = t211;
        C[i++] = t238;
        C[i++] = t246;
        C[i++] = t204;
        C[i++] = t249;
        C[i++] = t236;
        C[i++] = -volume*(mu+t102+lambda*(t54*t54)+mu*t4*t100*2.0);
        C[i++] = t201;
        C[i++] = t207;
        C[i++] = t260;
        C[i++] = t209;
        C[i++] = t235;
        C[i++] = t259;
        C[i++] = t199;
        C[i++] = t240;
        C[i++] = t201;
        C[i++] = -volume*(mu+t102+lambda*(t51*t51)+mu*t7*t100*2.0);
        C[i++] = t196;
        C[i++] = t257;
        C[i++] = t254;
        C[i++] = t206;
        C[i++] = t256;
        C[i++] = t253;
        C[i++] = t194;
        C[i++] = t207;
        C[i++] = t196;
        C[i++] = -volume*(mu+t102+lambda*(t48*t48)+mu*t10*t100*2.0);
        j -= 9;
        dpsidF[j++] = volume*(-F1_1*mu+F1_1*t101+lambda*t56*t155);
        dpsidF[j++] = -volume*(F2_1*mu+F2_1*t102+lambda*t53*t155);
        dpsidF[j++] = volume*(-F3_1*mu+F3_1*t101+lambda*t50*t155);
        dpsidF[j++] = -volume*(F1_2*mu+F1_2*t102+lambda*t55*t155);
        dpsidF[j++] = volume*(-F2_2*mu+F2_2*t101+lambda*t52*t155);
        dpsidF[j++] = -volume*(F3_2*mu+F3_2*t102+lambda*t49*t155);
        dpsidF[j++] = volume*(-F1_3*mu+F1_3*t101+lambda*t54*t155);
        dpsidF[j++] = -volume*(F2_3*mu+F2_3*t102+lambda*t51*t155);
        dpsidF[j++] = volume*(-F3_3*mu+F3_3*t101+lambda*t48*t155);

        psi[el] = (mu*(t2+t3+t4+t5+t6+t7+t8+t9+t10-3.0))/2.0+(lambda*(t155*t155))/2.0-(mu*log(t98))/2.0;
    }
    
    // migth bet better cache performance by building these things separately
    i = 0;
    int offset = 1;
    for ( int el = 0; el < m; el++ ) {
        for ( int j = 0; j < 81; j++ ) {
            ii[i] = offset + j % 9;
            jj[i] = offset + j / 9;
            i++;
        }
        offset += 9;
    }
}
