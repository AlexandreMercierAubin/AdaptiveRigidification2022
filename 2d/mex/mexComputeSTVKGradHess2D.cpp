/* mexCompute2DSTVKGradHess.c - computes negative area weighted STVK dpsidF and d2psidF2
 *
 * [ ii, jj, Cvals, dpsidF ] = mexComputeSTVKGradHess2D( F, A, mu, lambda );
 *
 * Input:
 *  F        4x#E deformation gradient of each element (or a vector of size 4x#E)
 *  A        #E area of each element
 *  mu       #E lamé parameter of each element
 *  lambda   #E lamé parameter of each element
 * 
 * Output:
 *  ii         16x#E by 1 row indices for each C block in a sparse matrix
 *  jj         16x#E by 1 col indices for each C block in a sparse matrix
 *  Cvals      16x#E by 1 energy Hessian wrt F for each eleemnt (scaled by negative area)
 *  dpsidF     4x#E by 1 energy gradient (scaled by negative area)
 *
 * To compile type: mex -R2018a mexComputeSTVKGradHess2D.cpp
 *
 * Notes:
 *
 * Code generated by scratch/codeGenSTVKHessian2D.m
 *
 * It is perhaps a tiny bit slower to build the sparse matrix with the 
 * matlab call sparse( ii, jj, Cvals ), rather than creating it here, but 
 * it could also be more useful in the long run to have the non-sparse 
 * version of the Cvals (e.g., a custom non-assembled matrix multiply for
 * the quick solve conjugate gradient).
 *========================================================*/

#include "mex.h"
#include "blas.h"

/* 
 * The gateway function
 */
void mexFunction( int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[] ) {
    // check for proper number of arguments
    if ( nrhs != 4 ) {
        mexErrMsgIdAndTxt("ARP:mexCompute2DSTVKGradHess:nrhs","four inputs required.");
    }
    if ( nlhs != 4 ) {
        mexErrMsgIdAndTxt("ARP:mexCompute2DSTVKGradHess:nlhs","four outputs required.");
    }
    
    // make sure the arguments are dense real double
    if ( !mxIsDouble(prhs[0]) || mxIsComplex(prhs[0]) || mxIsSparse(prhs[0]) ) {
        mexErrMsgIdAndTxt("ARP:mexCompute2DSTVKGradHess:mustBeDenseRealDouble","Parameters must be dense real double.");
    }
    if ( !mxIsDouble(prhs[1]) || mxIsComplex(prhs[1]) || mxIsSparse(prhs[1]) ) {
        mexErrMsgIdAndTxt("ARP:mexCompute2DSTVKGradHess:mustBeDenseRealDouble","Parameters must be dense real double.");
    }
    if ( !mxIsDouble(prhs[2]) || mxIsComplex(prhs[2]) || mxIsSparse(prhs[2]) ) {
        mexErrMsgIdAndTxt("ARP:mexCompute2DSTVKGradHess:mustBeDenseRealDouble","Parameters must be dense real double.");
    }
    if ( !mxIsDouble(prhs[3]) || mxIsComplex(prhs[3]) || mxIsSparse(prhs[3]) ) {
        mexErrMsgIdAndTxt("ARP:mexCompute2DSTVKGradHess:mustBeDenseRealDouble","Parameters must be dense real double.");
    }

    // check sizes    
    size_t Fsize = mxGetNumberOfElements(prhs[0]); // number of rows 
    if ( Fsize % 4 != 0 ) {
        mexErrMsgIdAndTxt("ARP:mexCompute2DSTVKGradHess:FSize","F must be a multiple of 4.");
    }
    size_t m = Fsize / 4;
    if ( mxGetNumberOfElements(prhs[1]) != m || mxGetNumberOfElements(prhs[2]) != m || mxGetNumberOfElements(prhs[3]) != m ) {
        mexErrMsgIdAndTxt("ARP:mexCompute2DSTVKGradHess:RowSize","All inputs must have same number of rows.");
    }
     
    double *FVals = mxGetDoubles(prhs[0]);
    double *AVals = mxGetDoubles(prhs[1]);
    double *muVals = mxGetDoubles(prhs[2]);
    double *lambdaVals = mxGetDoubles(prhs[3]);
    
    // create the output vectors 
    plhs[0] = mxCreateDoubleMatrix( 16*m, 1, mxREAL );
    double *ii = mxGetDoubles(plhs[0]);
    plhs[1] = mxCreateDoubleMatrix( 16*m, 1, mxREAL );
    double *jj = mxGetDoubles(plhs[1]);
    plhs[2] = mxCreateDoubleMatrix( 16*m, 1, mxREAL );
    double *C = mxGetDoubles(plhs[2]);
    plhs[3] = mxCreateDoubleMatrix( 4*m, 1, mxREAL );
    double *dpsidF = mxGetDoubles(plhs[3]);
    
    size_t i = 0;
    size_t j = 0;
    for ( int el = 0; el < m; el++ ) {
        double area = AVals[el];
        double mu = muVals[el];
        double lambda = lambdaVals[el];
        double F1_1 = FVals[j++];
        double F2_1 = FVals[j++];
        double F1_2 = FVals[j++];
        double F2_2 = FVals[j++];
        
        // code gen from scratch/codeGenSTVKHessian2D.m
        double t2 = F1_1*F1_1;
        double t3 = F1_2*F1_2;
        double  t4 = F2_1*F2_1;
        double  t5 = F2_2*F2_2;
        double  t6 = F1_1*F1_2;
        double  t7 = F1_1*F2_1;
        double  t8 = F1_2*F2_2;
        double  t9 = F2_1*F2_2;
        double  t12 = F1_1*F2_2*lambda;
        double  t13 = F1_2*F2_1*lambda;
        double  t16 = F1_1*F2_2*mu;
        double  t17 = F1_2*F2_1*mu;
        double  t10 = lambda*t6;
        double  t11 = lambda*t7;
        double  t14 = lambda*t8;
        double  t15 = lambda*t9;
        double  t18 = t6*2.0;
        double  t19 = t7*2.0;
        double  t20 = t8*2.0;
        double  t21 = t9*2.0;
        double  t22 = t6+t9;
        double  t27 = t12+t17;
        double  t28 = t13+t16;
        double  t29 = t2+t4-1.0;
        double  t30 = t3+t5-1.0;
        double  t23 = t6+t21;
        double  t24 = t7+t20;
        double  t25 = t9+t18;
        double  t26 = t8+t19;
        double  t35 = area*t27;
        double  t36 = area*t28;
        double  t43 = t29+t30;
        double  t31 = mu*t23;
        double  t32 = mu*t24;
        double  t33 = mu*t25;
        double  t34 = mu*t26;
        double  t37 = -t35;
        double  t38 = -t36;
        double  t52 = (lambda*t43)/2.0;
        double  t39 = t10+t33;
        double  t40 = t11+t34;
        double  t41 = t14+t32;
        double  t42 = t15+t31;
        double  t44 = area*t39;
        double  t45 = area*t40;
        double  t46 = area*t41;
        double  t47 = area*t42;
        double  t48 = -t44;
        double  t49 = -t45;
        double  t50 = -t46;
        double  t51 = -t47;
        
        C[i++] = -area*(t52+lambda*t2+mu*(t2*2.0+t3+t29));
        C[i++] = t49;
        C[i++] = t48;
        C[i++] = t37;
        C[i++] = t49;
        C[i++] = -area*(t52+lambda*t4+mu*(t4*2.0+t5+t29));
        C[i++] = t38;
        C[i++] = t51;
        C[i++] = t48;
        C[i++] = t38;
        C[i++] = -area*(t52+lambda*t3+mu*(t2+t3*2.0+t30));
        C[i++] = t50;
        C[i++] = t37;
        C[i++] = t51;
        C[i++] = t50;
        C[i++] = -area*(t52+lambda*t5+mu*(t4+t5*2.0+t30));

        j -= 4;
        dpsidF[j++] = -area*(F1_1*t52+mu*(F1_2*t22+F1_1*t29));
        dpsidF[j++] = -area*(F2_1*t52+mu*(F2_2*t22+F2_1*t29));
        dpsidF[j++] = -area*(F1_2*t52+mu*(F1_1*t22+F1_2*t30));
        dpsidF[j++] = -area*(F2_2*t52+mu*(F2_1*t22+F2_2*t30));
        
    }
    
    i = 0;
    int offset = 1;
    for ( int el = 0; el < m; el++ ) {
        for ( int j = 0; j < 16; j++ ) {
            ii[i] = offset + j % 4;
            jj[i] = offset + j / 4;
            i++;
        }
        offset += 4;
    }
}
