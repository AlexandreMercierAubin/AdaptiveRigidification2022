/* mexCompute2DSTVKGradHess.c - computes negative area weighted STVK dpsidF and d2psidF2
 *
 * [ ii, jj, Cvals, dpsidF ] = mexComputeSTVKGradHess2D( F, A, mu, lambda );
 *
 * Input:
 *  F        4x#E deformation gradient of each element (or a vector of size 4x#E)
 *  A        #E area of each element
 *  mu       #E lamé parameter of each element
 *  lambda   #E lamé parameter of each element
 * 
 * Output:
 *  ii         16x#E by 1 row indices for each C block in a sparse matrix
 *  jj         16x#E by 1 col indices for each C block in a sparse matrix
 *  Cvals      16x#E by 1 energy Hessian wrt F for each eleemnt (scaled by negative area)
 *  dpsidF     4x#E by 1 energy gradient (scaled by negative area)
 *
 * To compile type: mex -R2018a mexComputeSTVKGradHess2D.cpp
 *
 * Notes:
 *
 * Code generated by scratch/codeGenSTVKHessian2D.m
 *
 * It is perhaps a tiny bit slower to build the sparse matrix with the 
 * matlab call sparse( ii, jj, Cvals ), rather than creating it here, but 
 * it could also be more useful in the long run to have the non-sparse 
 * version of the Cvals (e.g., a custom non-assembled matrix multiply for
 * the quick solve conjugate gradient).
 *========================================================*/

#include "mex.h"
#include "blas.h"
#include <math.h>
/* 
 * The gateway function
 */
void mexFunction( int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[] ) {
    // check for proper number of arguments
    if ( nrhs != 4 ) {
        mexErrMsgIdAndTxt("ARP:mexCompute2DSTVKGradHess:nrhs","four inputs required.");
    }
    if ( nlhs != 5 ) {
        mexErrMsgIdAndTxt("ARP:mexCompute2DSTVKGradHess:nlhs","five outputs required.");
    }
    
    // make sure the arguments are dense real double
    if ( !mxIsDouble(prhs[0]) || mxIsComplex(prhs[0]) || mxIsSparse(prhs[0]) ) {
        mexErrMsgIdAndTxt("ARP:mexCompute2DSTVKGradHess:mustBeDenseRealDouble","Parameters must be dense real double.");
    }
    if ( !mxIsDouble(prhs[1]) || mxIsComplex(prhs[1]) || mxIsSparse(prhs[1]) ) {
        mexErrMsgIdAndTxt("ARP:mexCompute2DSTVKGradHess:mustBeDenseRealDouble","Parameters must be dense real double.");
    }
    if ( !mxIsDouble(prhs[2]) || mxIsComplex(prhs[2]) || mxIsSparse(prhs[2]) ) {
        mexErrMsgIdAndTxt("ARP:mexCompute2DSTVKGradHess:mustBeDenseRealDouble","Parameters must be dense real double.");
    }
    if ( !mxIsDouble(prhs[3]) || mxIsComplex(prhs[3]) || mxIsSparse(prhs[3]) ) {
        mexErrMsgIdAndTxt("ARP:mexCompute2DSTVKGradHess:mustBeDenseRealDouble","Parameters must be dense real double.");
    }

    // check sizes    
    size_t Fsize = mxGetNumberOfElements(prhs[0]); // number of rows 
    if ( Fsize % 4 != 0 ) {
        mexErrMsgIdAndTxt("ARP:mexCompute2DSTVKGradHess:FSize","F must be a multiple of 4.");
    }
    size_t m = Fsize / 4;
    if ( mxGetNumberOfElements(prhs[1]) != m || mxGetNumberOfElements(prhs[2]) != m || mxGetNumberOfElements(prhs[3]) != m ) {
        mexErrMsgIdAndTxt("ARP:mexCompute2DSTVKGradHess:RowSize","All inputs must have same number of rows.");
    }
     
    double *FVals = mxGetDoubles(prhs[0]);
    double *AVals = mxGetDoubles(prhs[1]);
    double *muVals = mxGetDoubles(prhs[2]);
    double *lambdaVals = mxGetDoubles(prhs[3]);
    
    // create the output vectors 
    plhs[0] = mxCreateDoubleMatrix( 16*m, 1, mxREAL );
    double *ii = mxGetDoubles(plhs[0]);
    plhs[1] = mxCreateDoubleMatrix( 16*m, 1, mxREAL );
    double *jj = mxGetDoubles(plhs[1]);
    plhs[2] = mxCreateDoubleMatrix( 16*m, 1, mxREAL );
    double *C = mxGetDoubles(plhs[2]);
    plhs[3] = mxCreateDoubleMatrix( 4*m, 1, mxREAL );
    double *dpsidF = mxGetDoubles(plhs[3]);
    plhs[4] = mxCreateDoubleMatrix( m, 1, mxREAL );
    double *psi = mxGetDoubles(plhs[4]);
    
    size_t i = 0;
    size_t j = 0;
    for ( int el = 0; el < m; el++ ) {
        double volume = AVals[el];
        double mu = muVals[el];
        double lambda = lambdaVals[el];
        double F1_1 = FVals[j++];
        double F2_1 = FVals[j++];
        double F1_2 = FVals[j++];
        double F2_2 = FVals[j++];
        
        // code gen from scratch/codeGenSTVKHessian2D.m
        double t2 = F1_1*F1_1;
        double t3 = F1_2*F1_2;
        double t4 = F2_1*F2_1;
        double t5 = F2_2*F2_2;
        double t6 = F1_1*F2_2;
        double t7 = F1_2*F2_1;
        double t8 = F1_1*F1_2*lambda;
        double t9 = F1_1*F2_1*lambda;
        double t12 = F1_2*F2_2*lambda;
        double t13 = F2_1*F2_2*lambda;
        double t14 = 1.0/lambda;
        double t10 = lambda*t6;
        double t11 = lambda*t7;
        double t15 = -t6;
        double t16 = mu*t14*(3.0/4.0);
        double t17 = t2+t3+t4+t5+1.0;
        double t18 = 1.0/t17;
        double t21 = t7+t15+t16+1.0;
        double t19 = t18*t18;
        double t20 = mu*t18;
        double t23 = lambda*t21;
        double t22 = -t20;
        double t24 = F1_1*F1_2*mu*t19*2.0;
        double t25 = F1_1*F2_1*mu*t19*2.0;
        double t26 = mu*t6*t19*2.0;
        double t27 = mu*t7*t19*2.0;
        double t28 = F1_2*F2_2*mu*t19*2.0;
        double t29 = F2_1*F2_2*mu*t19*2.0;
        double t30 = -t23;
        double t31 = -t24;
        double t32 = -t25;
        double t33 = -t28;
        double t34 = -t29;
        double t43 = t11+t23+t27;
        double t45 = t10+t26+t30;
        double t35 = t8+t34;
        double t36 = t9+t33;
        double t37 = t12+t32;
        double t38 = t13+t31;
        double t44 = t43*volume;
        double t46 = t45*volume;
        double t39 = t35*volume;
        double t40 = t36*volume;
        double t41 = t37*volume;
        double t42 = t38*volume;
        double t47 = -t44;
        double t48 = -t46;
        
        C[i++] = -volume*(mu+t22+lambda*t5+mu*t2*t19*2.0);
        C[i++] = t41;
        C[i++] = t42;
        C[i++] = t48;
        
        C[i++] = t41;
        C[i++] = -volume*(mu+t22+lambda*t3+mu*t4*t19*2.0);
        C[i++] = t47;
        C[i++] = t39;
        
        C[i++] = t42;
        C[i++] = t47;
        C[i++] = -volume*(mu+t22+lambda*t4+mu*t3*t19*2.0);
        C[i++] = t40;
        
        C[i++] = t48;
        C[i++] = t39;
        C[i++] = t40;
        C[i++] = -volume*(mu+t22+lambda*t2+mu*t5*t19*2.0);
  
        j -= 4;
        dpsidF[j++] = volume*(-F1_1*mu+F1_1*t20+F2_2*t23);
        dpsidF[j++] = -volume*(F2_1*mu+F1_2*t23+F2_1*t22);
        dpsidF[j++] = -volume*(F1_2*mu+F1_2*t22+F2_1*t23);
        dpsidF[j++] = volume*(-F2_2*mu+F1_1*t23+F2_2*t20);
        psi[el] = (t21*t23)/2.0-(mu*log(t17))/2.0+(mu*(t2+t3+t4+t5-2.0))/2.0;

    }
    
    i = 0;
    int offset = 1;
    for ( int el = 0; el < m; el++ ) {
        for ( int j = 0; j < 16; j++ ) {
            ii[i] = offset + j % 4;
            jj[i] = offset + j / 4;
            i++;
        }
        offset += 4;
    }
}
